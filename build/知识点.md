# 代码可读性
在代码中硬编码数字（如直接写 `40`）被称为“魔法数字”（magic number）。这种做法让代码可读性降低，因为其他开发者可能不知道 `40` 的意义。而 `sizeof(c)` 直接反映了数组大小，使代码更清晰



# 结构体
## typedef
### 用法:
`typedef`可以为类型定义==别名==，但它并不允许直接在声明时创建实例。`typedef`用于定义类型，但它不能同时用于创建变量或实例。你可以先定义一个结构体类型，然后再创建实例

> 
#### 1. 结构体类型的 `typedef`

通常，`typedef` 后面紧跟着结构体的定义体，然后再给结构体类型命名。

注意大括号前and后
```c
typedef struct {     char kemu[100];     
				int num; 
				} Subject;  // 结构体类型的别名 Subject`
```
此时是匿名的结构体,直接给他来了个别名

或者
```c
```typedef struct Subject {     char kemu[100];     
						   int num; } Subject;  // 结构体类型的别名 Subject
```
这种写法显式命名了结构体名称

#### 2. 不一定需要在大括号后面

你还可以在结构体定义外部定义类型别名，这样可以在结构体定义后使用：

```c
struct Subject {     char kemu[100];     int num; };  typedef struct Subject SubjectAlias;  // 使用 typedef 创建别名
```
这里，`typedef` 并不紧接在结构体定义的后面，而是分开写的。


>   struct Person   person是类型名
    int person   person是变量名

编译器默认变量声明上下文
	为了不冲突,默认单独出现的就是变量名了,加个struct就是类型名
`typedef`为类型创建了别名，把原本属于`struct`命名空间的名字直接放入==普通的类型==命名空间中，从而可以省略`struct`关键字.
使用 `typedef` 后，给结构体起了一个新名字，这个新名字被放入了普通的类型命名空间（即==与 `int`、`float` 等内置类型同属一个空间==），所以不再需要使用 `struct` 来引用它
>struct Person p1; // 声明变量 p1.age = 20
 实例p1作为一个普通变量,可以单独使用

## 结构体访问成员

    通过结构体实例：使用点运算符（.）来访问成员。  
    通过结构体指针：使用箭头运算符（->）来访问成员。
即使在没有显式声明某个结构体实例的情况下，你依然可以通过数组索引访问结构体实例的成员

==->== 运算符是 解引用指针并访问成员 的简写，它结合了 解引用 和 成员访问 两个操作.就是解应用得到原对象再访问

## 结构体交换

```c
Subject temp = s[j]; // Swap the structures s[j] = s[j + 1]; 
s[j + 1] = temp;
```
你使用的交换方法是通过值复制来交换两个结构体变量，所以整个结构体的内容（包括所有成员）都会被交换。

在C语言中，结构体是值传递类型，因此，当你交换结构体时，实际上是在交换结构体的副本

# 数组
## 字符数组
注意,最多读取n-1个,要记得留一个位置给\0

```c
char name[50]; // 定义字符数组，用来存储输入的字符串 printf("Enter your name: "); scanf("%s", name); // 使用 scanf 读取字符串输入 printf("Hello, %s!\n", name); // 输出输入的字符串
```
可以直接使用%s输入和输出,不过要赋值只能用strcpy

### 字符数组输入
其中当然可以有空格,只是scanf识别到空格就停下了,而gets不会停下
可以存空格,但存的媒介要考虑清楚
#### gets和fgets


`gets` 函数的参数应该是一个字符数组，而不是单个字符变量 `c`。所以，`gets(c);` 是错误的，正确的用法是直接用 `scanf` 或初始化数组来获取单个字符。
```c
统计字符串中字母、数字、空格和其他字符的个数。

### 输入格式:

在一行中输入长度不超过40的字符串。

### 输出格式:

第一行中输出“zimu=x“

第二行中输出“shuzi=y“

第三行中输出“kongge=z”，

第四行中输出“qita=m”
#include <stdio.h>
#include <string.h>

int main() {
    char c[40];
    fgets(c, sizeof(c), stdin);  // 使用fgets代替gets，避免缓冲区溢出

    int i, zimu = 0, shuzi = 0, kongge = 0, m = 0;

    // 获取字符串的有效长度，避免处理多余的字符
    int len = strlen(c);
    
    for (i = 0; i < len; i++) {
        if ((c[i] >= 'A' && c[i] <= 'Z') || (c[i] >= 'a' && c[i] <= 'z')) {
            zimu++;
        } else if (c[i] >= '0' && c[i] <= '9') {
            shuzi++;
        } else if (c[i] == ' ') {
            kongge++;
        } else {
            m++;
        }
    }

    // 输出结果
    printf("zimu=%d\n", zimu);
    printf("shuzi=%d\n", shuzi);
    printf("kongge=%d\n", kongge);
    printf("qita=%d\n", m);

    return 0;
}

```
gets会将没满的部分乱填充
- fgets
- **输入未满 39 字符：** 如果用户输入的字符少于 39（比如输入 `Hello` 后按下 `Enter`），那么 `fgets` 会读取：
    
    - 5 个字符 `Hello`
    - 1 个换行符 ==`\n`==
    - 1 个空字符 `\0`
    
    最终数组 `c` 的内容是：`{'H', 'e', 'l', 'l', 'o', '\n', '\0'}`。
    
- **输入超过 39 字符：** 例如输入 `This is a very long string that exceeds the limit`，`fgets` 会读取：
    
    - 前 39 个字符 `This is a very long string that exceed`
    - 1 个空字符 `\0`。
    
    剩余的字符 `s the limit` 保留在缓冲区中，可以通过后续调用 `fgets` 再次读取。
>fgets相当于数据去覆盖数组
如果输入字符少于 39 个，数组中未被覆盖的部分不会被 `fgets` 修改，它们的值取决于数组在内存中的初始状态，可能是随机的未定义数据
字符数组只有在初始化时，如果没有填满，剩余的部分才会自动填充为 `\0`

fgets(c,40,stdin);
    int len=strlen(c);
    int i,zimu=0,shuzi=0,kongge=0,m=0;
    for(i=0;i<len;i++)
所以如果没有==初始化数组==,那就要把循环长度控制在有效长度
不行,必须要限制为strlen,不然<40,后面自动填充的会被识别到,除非再写一个if判断
> 此题最重要的就是控制识别长度
> 控制了之后,就不用管你不满足的地方了,gets和fgets都是可以的


&&使用 `fgets()` 代替 `gets()`，它会限制输入的最大长度，并且可以有效防止溢出。同时，可以确保未使用的部分不被误认为有效字符

fgets会读取换行符,gets不会
去掉int len = 0; while (arr[len] != '\0' && arr[len] != '\n') { len++; } arr[len] = '\0';



### **数组越界问题**

`for (i = 0; i < 80; i++)` 遍历整个数组，但 `gets` 函数只读取一行输入，并用 `\0` 标记结束。因此，当 `arr[i]` 到达未被输入的数据区域时，可能会造成未定义行为。

修正方法： 使用输入的字符串长度作为循环的条件：
#for条件
for里面写的是能进行循环要满足的条件

```c
for (i = 0; arr[i] != '\0'; i++)`
```

"段错误"（Segmentation Fault，简称 "segfault"）是指程序访问了操作系统不允许访问的内存区域
越界,free*2

在C语言中，`fgets()` 和 `scanf()` 都会读取输入缓冲区的数据。当你调用 `fgets()` 读取一行输入时，它会将输入的数据（包括换行符 `\n`）存储在缓冲区中。如果输入的字符串长度小于指定的长度，剩余的部分就会被填充，换行符会保留在缓冲区。

当你接着调用 `scanf("%c")` 时，它会从缓冲区中读取字符。因为换行符还在缓冲区中，所以 `scanf` 会把这个换行符当作输入字符读取，导致意外的行为。这就可能是你遇到段错误或不预期结果的原因。

为了避免这个问题，通常我们会在读取字符之前清空输入缓冲区或者使用适当的输入方式，例如：

- 在 `fgets()` 之后，使用 `getchar()` 来读取并丢弃缓冲区中的换行符，确保下一次输入是新的数据。
- 使用 `scanf(" %c")`（注意前面的空格）来跳过任何前导空白字符，包括换行符。

# argv
是的，`char *arr[]` 在声明时通常需要指定数组的**元素个数**，特别是当你在声明一个字符指针数组时。让我们更详细地解释一下。

### **`char *arr[]` 声明的含义**

在声明 `char *arr[]` 时，`arr` 是一个字符指针数组。每个数组元素都是一个指向字符类型的指针 (`char *`)。

例如：

```c
char *arr[] = {"Hello", "World", "!"};
```

这里，`arr` 是一个字符指针数组，包含了 3 个元素。每个元素都是一个指向字符串的指针。

### **是否需要指定元素个数**

- **初始化时可以省略元素个数**：当你为数组提供了初始化列表时，编译器会自动推断数组的大小。例如：
    
    ```c
    char *arr[] = {"Hello", "World", "!"};
    ```
    
    在这种情况下，编译器会自动计算出数组有 3 个元素，并为 `arr` 分配相应大小的内存。因此，在初始化时，你不需要显式地指定数组的大小。
    
- **声明时需要指定大小**：如果你没有提供初始化列表，那么你必须显式地指定数组的元素个数。例如：
    
    ```c
    char *arr[3];  // 声明一个包含 3 个字符指针的数组
    ```
    
    在这种情况下，数组 `arr` 有 3 个元素，每个元素是一个 `char *` 类型的指针。
    

### **为什么要指定大小**

在 C 语言中，数组的大小是必须在编译时确定的。对于字符指针数组，虽然每个元素是一个指针，指针的大小是固定的，但我们需要指定数组元素的个数，以便编译器知道为这些指针分配多少内存。

- 如果你提供了初始化列表，编译器会根据列表中的元素自动推断出数组的大小。
- 如果没有初始化列表，编译器无法自动推断数组的大小，因此你必须显式地指定。

### **总结**

- **初始化时**，`char *arr[]` 可以不显式指定大小，编译器会根据初始化内容推断出元素的个数。
- **声明时**，如果没有初始化内容，必须显式指定数组的大小（如 `char *arr[3]`）。

argv是因为,我们有初始化它,应该就是程序传参吧
### **1. 数组与指针的基础概念**

首先，让我们理清数组和指针的基本概念：

- **数组**：一个数组是**连续存储的**内存块，数组内的元素是数据（例如：`int`、`char` 等），并且数组在声明时需要知道它包含多少个元素。数组的大小在声明时必须确定，因为它涉及到内存的分配和访问方式。
    
- **指针**：指针是一个**存储地址**的变量，它指向某个特定数据的位置。指针本身只需要存储一个地址（内存中的位置），所以指针的大小通常是固定的。指针大小通常是 4 字节（在 32 位系统上）或 8 字节（在 64 位系统上）。


#### **1. 在函数参数中使用普通数组时**

在函数参数中，数组的大小不能像局部数组一样自动推断出来。C 语言中，数组作为函数参数传递时，通常会被“退化”成指针，因此我们必须显式传递数组的大小。

例如：

c

复制代码

`void printArray(int arr[], int size) {     for (int i = 0; i < size; i++) {         printf("%d ", arr[i]);     } }`

在这里，`arr[]` 被视为一个指针，编译器不知道数组的实际大小，因此我们必须通过额外的 `size` 参数来告诉函数数组的大小。


是的，Emma，你理解得非常对！当你在 `main` 函数中使用 `char *arr[]` 来接收命令行参数时，确实不需要显式指定数组的大小，因为数组的大小是由传入的参数数量决定的，编译器会根据传入的参数自动推断。

### **`char *arr[]` 和 `main` 函数中的命令行参数**

在 `main` 函数中，`char *arr[]` 经常用于接收命令行参数。这里的 `arr` 是一个字符指针数组，其中每个元素是一个指向字符数组（即字符串）的指针。

常见的 `main` 函数定义是：

```c
int main(int argc, char *argv[])
```

- **`argc`**：表示命令行参数的数量，包括程序本身的名称。
- **`argv[]`**：是一个指向字符指针的数组，数组中的每个元素都是一个指向字符串的指针，这些字符串分别对应命令行中的各个参数。

### **为什么 `char *arr[]` 不需要指定大小**,因为已经有argc了!!

在 `main` 函数中，`argv[]` 数组的大小是由命令行传入的参数数量决定的，而不是固定的。在运行程序时，操作系统会将命令行参数传递给程序，并且会自动将这些参数存储在 `argv[]` 中。

例如：

```bash
./my_program arg1 arg2 arg3
```

当你运行这个命令时，操作系统会将 `"./my_program"`, `"arg1"`, `"arg2"`, `"arg3"` 作为命令行参数传递给程序，`argc` 会被设置为 4（因为有 4 个参数），而 `argv` 会是一个包含 4 个元素的数组。

具体到代码：

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    // argc 是传入参数的个数
    // argv 是一个字符指针数组，存储了每个参数的字符串
    for (int i = 0; i < argc; i++) {
        printf("argv[%d]: %s\n", i, argv[i]);
    }
    return 0;
}
```

在这种情况下，**`argv[]` 的大小由操作系统根据命令行参数的数量自动确定**，你不需要手动指定。

### **自动推断的原理**

在程序启动时，操作系统会根据传递给程序的参数个数来为 `argv[]` 分配内存。所以你不需要提前知道数组的大小，`argv[]` 会自动根据传入的命令行参数进行初始化，数组的每个元素都是一个指向字符串的指针。

### **总结**

- 在 `main` 函数中，`char *arr[]`（实际上是 `argv[]`）的大小是由程序启动时传入的命令行参数数量来决定的，因此不需要显式指定数组的大小。
- `argc` 给出了命令行参数的个数，而 `argv[]` 中存储的是这些参数的字符串。


# 目录
`DIR`是一个在C语言中定义的结构体类型，代表一个目录流。它在`<dirent.h>`头文件中被声明，用于存储与目录相关的信息，比如目录中每个文件或子目录的名称。

### `DIR`和`struct dirent`的关系

- `DIR`代表一个打开的目录流，它本身并不直接包含目录项，而是一个“连接”到目录的对象。
- `struct dirent`是描述单个目录项的结构，包含文件名和其他信息（如文件类型）。

## 函数
	首先,大的,目录类型(?)是DIR,小的,每个条目是结构体类型dirent 包含了文件inode和文件名

# -R
### `recursive`

- `recursive` 是一个布尔值变量，通常用于控制是否进行递归操作。它的值通常是 `true` 或 `false`，如果 `recursive` 为 `true`，则表示你希望递归遍历子目录；如果为 `false`，则表示只遍历当前目录。

### 2. `entry->d_type == DT_DIR`

- `entry` 是 `readdir` 函数返回的目录项，它是一个 `struct dirent` 类型的指针，代表当前目录中的一个文件或子目录。
- `d_type` 是 `struct dirent` 中的一个字段，它表示目录项的类型。
    - `DT_DIR` 是一个常量，表示目录类型。
    - `entry->d_type == DT_DIR` 判断当前目录项是否是一个目录。如果是目录，`d_type` 字段的值就会是 `DT_DIR`。

### 3. 条件的含义

- `if (recursive && entry->d_type == DT_DIR)` 这个条件表示：**如果`recursive`为`true`（即你希望递归遍历子目录），并且当前的目录项是一个目录（`entry->d_type == DT_DIR`），那么就执行递归操作**。
![[Pasted image 20241218212522.png]]

	

# U15  文件信息
## stat

在 C 语言中，`stat` 是一个用于获取文件状态信息的函数，它可以提供关于文件或目录的详细信息。`stat` 函数定义在 `<sys/stat.h>` 头文件中。

### 函数原型

```c
#include <sys/stat.h>

int stat(const char *path, struct stat *buf);
```

- **参数**：
    
    - `path`：文件或目录的路径。
    - `buf`：指向 `struct stat` 的指针，用于存储获取的文件信息。
- **返回值**：
    
    - 成功时，返回 `0`。
    - 失败时，返回 `-1`，并且设置 `errno` 来指示错误的原因。

### `struct stat` 结构体
`struct stat` 不是你自己定义的结构体，而是定义在 `<sys/stat.h>` 头文件中的。它是一个标准的结构体，用于存储文件的状态信息。

你无需手动定义 `struct stat`，只需包含 `<sys/stat.h>` 头文件，然后就可以使用它。这个结构体包含了获取文件信息时需要的各种字段，像文件大小、权限、访问时间等。

例如：

`#include <sys/stat.h>`

通过包含该头文件，你就可以使用 `struct stat` 结构体，以及相关的函数（如 `stat`、`fstat` 和 `lstat`）来操作文件状态。
==结构体本身只是定义了数据的布局和类型，但并不包含具体的数据。你需要构建结构体的实例，并给它提供实际的数据。


`stat` 函数通过填充 `struct stat` 结构体来返回文件的状态信息。`struct stat` 包含了文件的各种属性，主要字段包括：

```c
struct stat {
    dev_t     st_dev;     /* 设备 ID */
    ino_t     st_ino;     /* 文件的 inode 号码 */
    mode_t    st_mode;    /* 文件类型和访问权限 */
    nlink_t   st_nlink;   /* 硬链接的数量 */
    uid_t     st_uid;     /* 文件所有者的用户 ID */
    gid_t     st_gid;     /* 文件所有者的组 ID */
    dev_t     st_rdev;    /* 设备文件的设备 ID */
    off_t     st_size;    /* 文件大小（字节数） */
    blksize_t st_blksize; /* 文件系统 I/O 的最优块大小 */
    blkcnt_t  st_blocks;  /* 文件占用的 512 字节块数 */
    time_t    st_atime;   /* 上次访问时间 */
    time_t    st_mtime;   /* 上次修改时间 */
    time_t    st_ctime;   /* 上次状态改变时间 */
};
```

### 常用字段说明

- **st_mode**：文件类型和访问权限，包含了文件的类型（如普通文件、目录、符号链接等）以及权限（读、写、执行）。
- **st_size**：文件的大小，单位是字节。
- **st_uid** 和 **st_gid**：分别表示文件所有者的用户 ID 和组 ID。
- **st_atime**、**st_mtime** 和 **st_ctime**：分别表示文件的最后访问时间、最后修改时间和最后状态改变时间。
- **st_nlink**：表示文件的硬链接数量。

### 常见的 `st_mode` 文件类型标志

- `S_IFREG`：普通文件
- `S_IFDIR`：目录
- `S_IFLNK`：符号链接
- `S_IFCHR`：字符设备
- `S_IFBLK`：块设备
- `S_IFIFO`：命名管道（FIFO）
- `S_IFSOCK`：套接字

### 使用示例

```c
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>

int main() {
    struct stat buf;
    
    // 获取文件状态信息
    if (stat("example.txt", &buf) == -1) {
        perror("stat failed");
        return 1;
    }

    // 输出文件信息
    printf("File size: %ld bytes\n", buf.st_size);
    printf("Last accessed: %ld\n", buf.st_atime);
    printf("Last modified: %ld\n", buf.st_mtime);
    printf("Last status change: %ld\n", buf.st_ctime);

    // 判断文件类型
    if (S_ISDIR(buf.st_mode)) {
        printf("It is a directory.\n");
    } else if (S_ISREG(buf.st_mode)) {
        printf("It is a regular file.\n");
    }

    return 0;
}
```

### `stat` 常见的用途

1. **检查文件类型**：通过 `st_mode` 字段，可以检查文件是否为目录、常规文件、符号链接等。
2. **获取文件大小**：通过 `st_size` 获取文件的大小。
3. **获取文件的修改时间、访问时间**：通过 `st_mtime`、`st_atime` 和 `st_ctime` 获取文件的时间信息。
4. **检查文件权限**：通过 `st_mode` 还可以检查文件的读、写、执行权限。

### `stat` 和 `fstat` / `lstat` 的区别

- `stat`：获取指定路径文件的信息。
- `fstat`：获取通过文件描述符指定的文件的信息。
- `lstat`：与 `stat` 类似，但对符号链接特殊处理，`lstat` 不会跟随符号链接获取其目标文件的信息，而是返回符号链接本身的信息。

`stat` 是一个非常有用的系统调用，能够帮助我们获得文件的详细状态信息，广泛应用于文件管理和文件操作程序中。

# snprintf
|**`snprintf`**|**`strcat`**|
|---|---|

|   |   |   |
|---|---|---|
|**用途**|格式化字符串，支持插入变量或格式化数据|拼接字符串，将一个字符串连接到另一个字符串末尾|

|   |   |   |
|---|---|---|
|**安全性**|指定缓冲区大小，防止缓冲区溢出|不检查目标缓冲区大小，可能导致缓冲区溢出|

|   |   |   |
|---|---|---|
|**复杂度**|复杂：支持格式化（比如整数、浮点数等）|简单：只处理字符串，没有格式化功能|

|   |   |   |
|---|---|---|
|**输入**|格式化字符串和变量|两个字符串|

|         |                         |            |
| ------- | ----------------------- | ---------- |
| **返回值** | 返回需要的缓冲区大小（不包括结束符 `\0`） | 返回目标字符串的地址 |

目标位置,大小,格式,原本,后面
snprintf(new_path, sizeof(new_path), "%s/%s", path, entry->d_name);




### `exit` 函数概述

  

`exit` 函数定义在 `<stdlib.h>` 头文件中，其作用是终止当前正在执行的程序，并将控制权返回给操作系统。它会执行一系列的清理操作，然后结束程序的运行。